- Testing Implementation
	- Overview
		- Two test targets: unit tests (`final finalTests`) and UI tests (`final finalUITests`)
		- Unit tests use both XCTest and Swift Testing frameworks
		- UI tests use XCTest exclusively (XCUITest)
		- Test fixture system provides pre-built `.ff` project files for tests that need editor content
		- Test mode detection uses environment variables (`FF_UI_TESTING`, `FF_TEST_FIXTURE_PATH`) passed via `launchEnvironment`, not command-line arguments
	- Test Targets
		- `final finalTests` (Unit / Integration)
			- Runs inside the app process with `@testable import final_final`
			- Has access to all internal types, database APIs, and WebView bridge
			- Tests
				- `FinalFinalTests.swift` — placeholder test (passes trivially)
				- `OutlineParserTests.swift` — 8 tests for markdown-to-outline parsing
					- Header detection, nesting, offsets, pseudo-sections, code block exclusion, preview extraction, word count
					- Uses Swift Testing (`@Test`, `#expect`)
					- Pure logic tests, no I/O
				- `ProjectRepairServiceTests.swift` — 10 tests for database corruption repair
					- Covers: missing project records, missing tables, orphaned sections, empty databases, backup creation, severity ordering
					- Uses Swift Testing
					- Creates temporary SQLite databases in `/tmp/claude/` via `CorruptedDatabaseFactory`
					- Two tests (`repairRealCorruptedBackupDemo1`, `repairRealCorruptedBackupDemo2`) depend on external backup files at a specific path; they skip gracefully if the files don't exist
				- `EditorBridgeTests.swift` — 9 tests for JS-Swift WebView bridge
					- `MilkdownBridgeTests` (5 tests): editor loading, content roundtrip, stats accuracy, snapshot capture, focus mode toggle
					- `CodeMirrorBridgeTests` (4 tests): editor loading, content roundtrip, stats accuracy, snapshot capture
					- Uses XCTest (not Swift Testing) because WKWebView tests must not run in parallel
					- Creates real `WKWebView` instances with the `editor://` scheme handler
					- 300ms sleep delays after `setContent()` to allow editor JS to settle
				- `FixtureGeneratorTests.swift` — 2 tests for test fixture management
					- `testGenerateCommittedFixture`: creates a fresh `.ff` fixture using `ProjectDatabase` APIs; outputs to `/tmp/claude/test-fixture.ff` or `FIXTURE_OUTPUT_PATH` env var
					- `testCommittedFixtureIsValid`: opens the committed fixture and validates it has expected content; skips if fixture not found
			- Helpers
				- `TestFixtureFactory.swift` — creates `.ff` fixtures with canonical test content ("# Test Document ... ## Second Section ...")
				- `EditorTestHelper.swift` — `WKWebView` wrapper for bridge testing; loads editors via `editor://` scheme, polls for JS readiness, provides typed `EditorSnapshot` capture
		- `final finalUITests` (UI / Smoke Tests)
			- Runs out-of-process via XCUITest; interacts with the app through accessibility APIs
			- Cannot inspect internal state or cross-process content; relies on accessibility identifiers and status bar text
			- Tests
				- `LaunchSmokeTests` (no fixture needed)
					- `testAppLaunches` — verifies app boots without crash and shows either project picker or editor within 10 seconds
					- `testProjectPickerVisible` — verifies picker appears with "New Project" and "Open Project" buttons when no fixture is provided
				- `EditorSmokeTests` (fixture required)
					- `testEditorOpensWithFixture` — verifies editor area appears and status bar shows word count
					- `testEditorModeToggle` — verifies Cmd+/ toggles between WYSIWYG and Source modes via status bar text
					- `testSidebarToggles` — verifies Cmd+[ toggles outline sidebar visibility
					- `testFocusModeToggle` — verifies Cmd+Shift+F enters focus mode (hides status bar), Esc exits it
			- Helpers
				- `UITestHelpers.swift` — launch configuration, fixture setup, wait utilities
					- `XCUIApplication.targetApp()` — creates app reference by bundle ID (`com.kerim.final-final`) to avoid issues with the pipe character in `FINAL|FINAL`
					- `launchForTesting()` / `launchForTesting(fixturePath:)` — sets `launchEnvironment` variables and launches
					- `cleanSavedApplicationState()` — removes saved window state from both test runner home and real user home
					- `TestFixtureHelper` — copies committed fixture from UI test bundle to `/tmp/` and cleans up in tearDown
					- `waitForExistenceOrFail()` / `waitForDisappearance()` — XCUIElement wait extensions
	- Test Mode Architecture
		- How the app detects test mode
			- `TestMode.swift` reads environment variables, not command-line arguments
			- `TestMode.isUITesting` checks `ProcessInfo.processInfo.environment["FF_UI_TESTING"] == "1"`
			- `TestMode.testFixturePath` reads `ProcessInfo.processInfo.environment["FF_TEST_FIXTURE_PATH"]`
			- `TestMode.clearTestState()` removes UserDefaults keys that could interfere with test isolation (last project bookmark, recent projects, focus mode, etc.)
		- Why environment variables instead of arguments
			- Apple bug FB15577018: SwiftUI macOS apps compiled with Xcode 16+ can fail to show windows when launched with command-line arguments
			- `XCUIApplication.launch()` bypasses LaunchServices, and when combined with arguments, SwiftUI's `WindowGroup` never creates its initial `NSWindow`
			- `launchEnvironment` passes values as process environment variables, which do not trigger this bug
			- `open -a` with `--args` works fine because it goes through LaunchServices; the issue is specifically `XCUIApplication.launch()`
		- LaunchServices fallback (safety net)
			- In `AppDelegate.applicationDidFinishLaunching`, if in test mode, a 0.5-second delayed check runs
			- If `NSApp.windows` is empty after the delay, re-activates the app via `NSWorkspace.shared.openApplication(at: Bundle.main.bundleURL)`, which goes through LaunchServices and sends the proper Apple Events to trigger `WindowGroup` window creation
			- In practice, the environment variable fix alone is sufficient and this fallback does not trigger
	- Test Fixture System
		- How fixtures work
			- A `.ff` file is a directory package containing `content.sqlite` (GRDB database with all migrations applied)
			- `TestFixtureFactory.createFixture(at:)` creates fixtures using `ProjectDatabase` APIs, ensuring they match the current schema
			- The committed fixture lives at `final finalTests/Fixtures/test-fixture.ff/` and is included in the UI test bundle via `project.yml`
		- Regenerating the fixture
			- Run `FixtureGeneratorTests/testGenerateCommittedFixture` to create a new fixture
			- Copy from `/tmp/claude/test-fixture.ff` to `final finalTests/Fixtures/test-fixture.ff`
			- Required after schema migrations change (otherwise `testCommittedFixtureIsValid` will catch the drift)
		- How UI tests use fixtures
			- `TestFixtureHelper.setupFixture(from:)` copies the fixture from the UI test bundle to `/tmp/ff-test-fixture.ff`
			- The path is passed to the app via `FF_TEST_FIXTURE_PATH` environment variable
			- The app opens it directly in `determineInitialState()`, bypassing the project picker
			- `TestFixtureHelper.cleanupFixture()` removes the temp copy in `tearDown`
	- Running Tests
		- Commands
			- Full unit test suite: `xcodebuild test -scheme "final final" -destination 'platform=macOS' -only-testing "final finalTests"`
			- Full UI test suite: `xcodebuild test -scheme "final final" -destination 'platform=macOS' -only-testing "final finalUITests"`
			- Single test: `xcodebuild test -scheme "final final" -destination 'platform=macOS' -only-testing "final finalUITests/LaunchSmokeTests/testAppLaunches"`
		- Prerequisites
			- Web editors must be built first: `cd web && pnpm install && pnpm build`
			- Xcode project must be generated: `xcodegen generate`
			- The app must build successfully before tests can run
		- Sandbox note
			- When running via Claude Code, `xcodebuild` requires sandbox disabled (`dangerouslyDisableSandbox: true`) because SPM package resolution needs network access
			- After the first successful build (packages cached), subsequent builds may work in sandbox
	- Known Issues and Troubleshooting
		- XCUITest 0-windows bug
			- Symptom: `testAppLaunches` fails with "App should show picker or editor after launch"; `app.windows.count` is 0
			- Root cause: `XCUIApplication.launch()` bypasses LaunchServices, so `WindowGroup` never receives the `kAEOpenApplication` event
			- Fix: use `launchEnvironment` instead of `launchArguments` in `UITestHelpers.swift`
			- If it recurs: check that `TestMode.isUITesting` reads from environment (not arguments), and that `launchForTesting()` sets `launchEnvironment["FF_UI_TESTING"]` not `launchArguments`
			- The LaunchServices fallback in `AppDelegate` provides a second line of defense
		- Editor status bar timing failures
			- Symptom: `testEditorOpensWithFixture` fails on "Status bar should display word count" or `testEditorModeToggle` fails with empty editor mode label
			- Root cause: WebView editor loads asynchronously; status bar text is populated after JS editor initialization, which can take longer than the test expects
			- Mitigation: increase `waitForExistence` timeouts, or add explicit waits for status bar text to become non-empty before asserting on content
			- These are intermittent and depend on machine load; they pass reliably when the system is not under heavy load
		- Saved application state interference
			- Symptom: app restores a previous window state instead of showing the expected test view
			- Root cause: macOS saves window state in `~/Library/Saved Application State/com.kerim.final-final.savedState/`
			- Fix: `cleanSavedApplicationState()` removes this directory from both the test runner's home and the real user home before each test launch; additionally, the app itself cleans saved state in `applicationWillFinishLaunching` when in test mode
		- Test fixture not found
			- Symptom: `EditorSmokeTests` fail with "Test fixture not found in UI test bundle"
			- Root cause: the committed fixture at `final finalTests/Fixtures/test-fixture.ff` is missing or not included in the UI test bundle
			- Fix: regenerate the fixture (see "Regenerating the fixture" above), then ensure `project.yml` includes `final finalTests/Fixtures` in the `final finalUITests` target sources
		- SPM resolution failure during build
			- Symptom: build fails with "fatalError" or "cannot open file ... for diagnostics emission (Operation not permitted)"
			- Root cause: sandbox blocks network access to package registries
			- Fix: run `xcodebuild` with sandbox disabled for the initial build; subsequent builds use cached packages
		- App already running from previous test
			- Symptom: test connects to a stale app instance with wrong state
			- Root cause: XCUITest's `launch()` calls `terminate()` first, but if the app is hung, termination may not complete
			- Fix: if tests behave erratically, manually kill the app process (`killall "FINAL|FINAL"`) before re-running
	- Architecture Decisions
		- Why XCTest for EditorBridgeTests (not Swift Testing)
			- WKWebView tests require sequential execution; Swift Testing runs tests in parallel by default
			- XCTest's `setUp()` / `tearDown()` lifecycle is simpler for async WebView operations
			- Swift Testing's `@Suite(.serialized)` would work but adds complexity for no benefit here
		- Why bundle ID targeting for XCUIApplication
			- The app's `PRODUCT_NAME` is `FINAL|FINAL` (contains a pipe character)
			- `XCUIApplication()` with default targeting may fail to match due to the pipe
			- `XCUIApplication(bundleIdentifier: "com.kerim.final-final")` is unambiguous
		- Why environment variables for test mode detection
			- Avoids the Apple `WindowGroup` + arguments bug (FB15577018)
			- Cleaner API: no argument parsing, no index arithmetic
			- Environment variables don't interfere with the app's `CommandLine.arguments` processing
		- Why two-path saved state cleanup
			- The test runner's `NSHomeDirectory()` may be containerized (points to an Xcode-managed sandbox directory)
			- The app's `NSHomeDirectory()` is the real user home
			- Both paths must be cleaned to ensure no stale state from either context

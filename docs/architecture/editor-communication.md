# Editor Communication

WebView bridge, source mode specifics, SectionSyncService, find bar, and bibliography section architecture.

---

## WebView Communication

Both editors use the same bridge pattern:

```javascript
// window.FinalFinal API (exposed by editor JavaScript)
// --- Content ---
setContent(markdown)                   // Load content into editor
getContent()                           // Get current markdown
setContentWithBlockIds(md, ids, opts)  // Atomic content + block ID push

// --- Block sync (300ms polling) ---
hasBlockChanges()         // Check for pending changes (returns boolean)
getBlockChanges()         // Get {updates, inserts, deletes} changeset
syncBlockIds(ids)         // Align editor block order with DB IDs
confirmBlockIds(mapping)  // Confirm temp->permanent ID mapping

// --- UI ---
setFocusMode(enabled)    // Toggle paragraph dimming (WYSIWYG only)
getStats()               // Returns {words, characters}
scrollToOffset(n)        // Scroll to character offset
setTheme(css)            // Apply theme CSS variables
```

**Polling**: Two polling loops run concurrently:
- **Block polling** (300ms): `BlockSyncService` polls `hasBlockChanges()` -> `getBlockChanges()` for structural content sync
- **Content polling** (500ms): Reads `getContent()` for content binding + annotation sync via `SectionSyncService`

**Feedback Prevention**: `isSettingContent` flag prevents feedback loops when Swift pushes content to editor. `resetAndSnapshot(doc)` must be called after any `setContent()` to prevent false change waves. `isSyncSuppressed` on BlockSyncService gates polling during drag operations and block ID pushes.

---

## Source Mode Specifics

**Heading NodeView Plugin** (`heading-nodeview-plugin.ts`):
- WYSIWYG mode: Renders `<h2><span>content</span></h2>` with `heading-empty` class when empty
- Source mode: Renders headers with editable `## ` prefix in the text content

**Source Mode Plugin** (`source-mode-plugin.ts`):
- Adds `body.source-mode` class for CSS targeting
- Provides visual differentiation of markdown syntax

**Anchor Injection**: When switching to source mode, anchors are injected based on section startOffsets. When switching back, anchors are extracted and stripped.

---

## SectionSyncService

> **Note:** `BlockSyncService` is now the primary sync mechanism for content. SectionSyncService retains auxiliary roles described below.

Responsible for legacy section sync, anchor injection/extraction, and bibliography marker management.

**Remaining Roles**:
- `injectSectionAnchors(markdown:sections:)` -- Adds `<!-- @sid:UUID -->` for source mode
- `extractSectionAnchors(markdown:)` -- Removes anchors, returns mappings
- `injectBibliographyMarker` -- Adds `<!-- ::auto-bibliography:: -->` before bibliography header in source mode
- Legacy section table sync (dual-write for backward compatibility)

**Key Methods**:
- `contentChanged(_ markdown:)` -- Debounced entry point (500ms)
- `syncContent(_ markdown:)` -- Parses headers, reconciles with database
- `parseHeaders(from markdown:)` -- Extracts section boundaries

**Reconciliation**: Uses `SectionReconciler` to compute minimal database changes (insert, update, delete) by comparing parsed headers against existing sections.

---

## Find Bar Architecture

The find bar provides native-style find and replace functionality using JavaScript APIs exposed by both editors.

**State Management** (`FindBarState.swift`):
- Observable state for visibility, search query, replace text, match counts
- Holds weak reference to active `WKWebView` for JavaScript calls
- Uses `focusRequestCount: Int` (not boolean) to trigger focus requests reliably

**Focus Request Pattern**: SwiftUI's `.onChange` requires actual value changes to fire. A boolean toggle (`true` -> `false` -> `true`) can be coalesced by SwiftUI. An incrementing counter always changes, guaranteeing the `.onChange` fires:

```swift
// In FindBarState
var focusRequestCount = 0

func show(withReplace: Bool = false) {
    isVisible = true
    focusRequestCount += 1  // Always triggers .onChange
}

// In FindBarView
.onChange(of: state.focusRequestCount) { _, _ in
    isSearchFieldFocused = true
}
```

**Zoom Integration**: Search state is cleared when zooming in/out to prevent stale highlights from appearing on different content scopes.

**JavaScript API** (`window.FinalFinal.find*`):
- `find(query, options)` -- Start search, returns `{matchCount, currentIndex}`
- `findNext()` / `findPrevious()` -- Navigate matches
- `replaceCurrent(text)` / `replaceAll(text)` -- Replace operations
- `clearSearch()` -- Remove highlights
- `getSearchState()` -- Get current match info

---

## Bibliography Section Architecture

The bibliography section is auto-generated by `BibliographySyncService` when citations exist in the document. It follows the **section anchor pattern** for visibility control:

**Data Storage**: Bibliography `markdownContent` is stored **without** the marker:
```markdown
# Bibliography

Author, A. (2024). Title. *Journal*.
```

**Data Flow**:
1. **Milkdown (WYSIWYG)**: `editorState.content` contains clean content -- bibliography renders as normal `# Bibliography` heading
2. **CodeMirror (Source)**: `editorState.sourceContent` includes injected marker (`<!-- ::auto-bibliography:: -->`) before the bibliography header
3. **CodeMirror hides the marker** using the same decoration system that hides section anchors

**Marker Injection** (`SectionSyncService.injectBibliographyMarker`):
- Called when switching to source mode, after `injectSectionAnchors()`
- Finds bibliography section by `isBibliography` flag
- Inserts `<!-- ::auto-bibliography:: -->` before the bibliography header

**Bibliography Detection** (in parsers):
- **With marker**: Legacy support -- parsers detect `<!-- ::auto-bibliography:: -->` prefix
- **Without marker**: Parsers receive `existingBibTitle` parameter to identify bibliography by title match against existing sections
- Bibliography sections are excluded from normal section parsing (managed separately by `BibliographySyncService`)

**Migration**: Old content with embedded markers is cleaned when:
- Loading content from database (`stripBibliographyMarker`)
- Initializing `SectionViewModel` from database sections
- Rebuilding document content from sections
